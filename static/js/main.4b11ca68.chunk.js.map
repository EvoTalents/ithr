{"version":3,"sources":["components/Candidates/Candidates.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["CandidatesList","candidates","className","map","candidate","key","_id","index","name","currentPosition","desiredPosition","cities","citiesOptions","value","label","citiesMap","reduce","acc","city","candidatesReducer","state","action","type","payload","totalCount","skip","Math","min","limit","max","filters","defaultStore","techStack","Cities","c","join","Candidates","useReducer","dispatch","useEffect","url","URL","searchParams","append","toString","length","fetch","href","then","response","json","console","log","items","setCities","nextPage","prevPage","useCandidates","hasPrevPage","hasNextPage","options","isMulti","filter","includes","onChange","data","onClick","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.4b11ca68.chunk.js","sourcesContent":["import React, { Reducer, useEffect, useReducer, useState } from \"react\";\nimport Select from \"react-select\";\n\ninterface Candidate {\n  years: number;\n  name: string | null;\n  _id: string;\n  _owner: string;\n  _createdDate: {\n    $date: string;\n  };\n  _updatedDate: {\n    $date: string;\n  };\n  english: string;\n  contacts: string | null;\n  cv: string | null;\n  salary: string;\n  currentPosition: string;\n  canShow: boolean;\n  desiredPosition: string;\n  techStack: string[];\n  summary: string;\n  linkedIn: string | null;\n  cities: string[];\n  index: number;\n}\n\ninterface CandidatesResponse {\n  items: Candidate[];\n  totalCount: number;\n  skip: number;\n  limit: number;\n}\n\ninterface ListProps {\n  candidates: Candidate[];\n}\n\nconst CandidatesList: React.FC<ListProps> = ({ candidates }) => (\n  <table className=\"table\">\n    <thead>\n      <tr>\n        <th>#</th>\n        <th>Имя</th>\n        <th>Текущая позиция</th>\n        <th>Желаемая позиция</th>\n        <th>Город</th>\n      </tr>\n    </thead>\n    <tbody>\n      {candidates.map((candidate) => (\n        <tr key={candidate._id}>\n          <td>{candidate.index}</td>\n          <td>{candidate.name}</td>\n          <td>{candidate.currentPosition}</td>\n          <td>{candidate.desiredPosition}</td>\n          <td>\n            <Cities cities={candidate.cities} />\n          </td>\n        </tr>\n      ))}\n    </tbody>\n  </table>\n);\n\ninterface Filters {\n  cities: string[];\n  techStack: string[];\n}\n\ninterface Store {\n  candidates: Candidate[];\n  filters: Filters;\n  totalCount: number;\n  skip: number;\n  limit: number;\n}\n\ninterface SetCandidatesAction {\n  type: \"setCandidates\";\n  payload: { candidates: Candidate[]; totalCount: number };\n}\n\ninterface NextPageAction {\n  type: \"nextPage\";\n}\n\ninterface PrevPageAction {\n  type: \"prevPage\";\n}\n\ninterface FilterCitiesAction {\n  type: \"filterCities\";\n  payload: string[];\n}\n\ntype Action =\n  | SetCandidatesAction\n  | NextPageAction\n  | PrevPageAction\n  | FilterCitiesAction; //'setCandidates' | 'nextPage' | 'prevPage' | 'filterCity' | 'filterTechState'\n\nconst citiesOptions = [\n  { value: \"dnipro\", label: \"Днепр\" },\n  { value: \"kyiv\", label: \"Киев\" },\n  { value: \"kharkiv\", label: \"Харьков\" },\n  { value: \"lviv\", label: \"Львов\" },\n  { value: \"odessa\", label: \"Одесса\" },\n  { value: \"remote\", label: \"Remote\" },\n  { value: \"other\", label: \"Other\" },\n];\n\nconst citiesMap = citiesOptions.reduce(\n  (acc, city) => ({\n    ...acc,\n    [city.value]: city.label,\n  }),\n  {}\n);\n\nconst candidatesReducer: Reducer<Store, Action> = (state, action) => {\n  switch (action.type) {\n    case \"setCandidates\": {\n      return {\n        ...state,\n        candidates: action.payload.candidates,\n        totalCount: action.payload.totalCount,\n      };\n    }\n    case \"nextPage\": {\n      return {\n        ...state,\n        skip: Math.min(state.skip + state.limit, state.totalCount),\n      };\n    }\n    case \"prevPage\": {\n      return {\n        ...state,\n        skip: Math.max(state.skip - state.limit, 0),\n      };\n    }\n    case \"filterCities\": {\n      return {\n        ...state,\n        filters: {\n          ...state.filters,\n          cities: action.payload,\n        },\n      };\n    }\n    default:\n      return state;\n  }\n};\nconst defaultStore: Store = {\n  candidates: [],\n  skip: 0,\n  limit: 50,\n  totalCount: 0,\n  filters: {\n    cities: [],\n    techStack: [],\n  },\n};\n\nconst useCandidates = () => {\n  const [\n    { candidates, filters, skip, limit, totalCount },\n    dispatch,\n  ] = useReducer<Reducer<Store, Action>>(candidatesReducer, defaultStore);\n  const { cities, techStack } = filters;\n  // const [candidates, setCandidates] = useState<Candidate[]>([]);\n  useEffect(() => {\n    const url = new URL(\n      \"https://hr0153.wixsite.com/ithr/_functions-dev/candidates\"\n    );\n\n    if (skip) {\n      url.searchParams.append(\"skip\", skip.toString());\n    }\n    if (cities && cities.length) {\n      url.searchParams.append(\"cities\", cities.join(\",\"));\n    }\n    fetch(url.href)\n      .then((response) => response.json())\n      .then((response: CandidatesResponse) => {\n        console.log(response);\n        dispatch({\n          type: \"setCandidates\",\n          payload: {\n            candidates: response.items,\n            totalCount: response.totalCount,\n          },\n        });\n      });\n  }, [skip, cities]);\n  return {\n    candidates,\n    skip,\n    totalCount,\n    limit,\n    cities: filters.cities,\n    setCities: (cities: string[]) => {\n      dispatch({ type: \"filterCities\", payload: cities });\n    },\n\n    nextPage: () => {\n      dispatch({ type: \"nextPage\" });\n    },\n    prevPage: () => {\n      dispatch({ type: \"prevPage\" });\n    },\n  };\n};\n\nconst Cities: React.FC<{ cities: string[] }> = ({ cities }) => {\n  return <div>{cities.map((c: any) => (citiesMap as any)[c]).join(\", \")}</div>;\n};\n\nexport const Candidates: React.FC = () => {\n  const {\n    candidates,\n    skip,\n    limit,\n    totalCount,\n    cities,\n    setCities,\n    nextPage,\n    prevPage,\n  } = useCandidates();\n  if (!candidates.length) {\n    return <div>Loading...</div>;\n  }\n  const hasPrevPage = skip > 0;\n  console.log(\"skip\", skip);\n  console.log(\"limit\", limit);\n  console.log(\"totalCount\", totalCount);\n  const hasNextPage = skip + limit < totalCount;\n  return (\n    <div>\n      <Select\n        options={citiesOptions}\n        isMulti\n        value={citiesOptions.filter((c) => cities.includes(c.value))}\n        onChange={(data) => {\n          console.log(\"data\", data);\n          setCities(((data || []) as any).map((c: any) => c.value));\n        }}\n      />\n      <CandidatesList candidates={candidates} />\n      <div>\n        {hasPrevPage ? <button onClick={prevPage}>&lt;</button> : null}\n        {hasNextPage ? <button onClick={nextPage}>&gt;</button> : null}\n      </div>\n    </div>\n  );\n};\n","import React from \"react\";\nimport \"./App.css\";\nimport { Candidates } from \"./components/Candidates/Candidates\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Candidates />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}